# Augments a given Haskell package set using definitions taken from a
# "tincified" Haskell package, i.e. one where the dependencies have been solved
# by Cabal and turned into a set of (mutually-recursive) Nix expressions by tinc
# and cabal2nix.
#
# We also allow "extra" packages to be supplied, since we can't easily use the
# "add source" facility of Cabal/tinc.
#
# Since the generated definitions in <tincified>/tinc.nix reference each other
# directly, the callPackage function we pass in only has to resolve the extras.
# We assume the extras are present in the given haskellPackages, so we use its
# callPackage function.
{ lib }: with lib;

{ extras ? [], haskellPackages, nixpkgs ? import <nixpkgs> {}, tincified }:
with rec {
  # Loads the package definitions generated by tinc
  deps = import "${tincified}/tinc.nix" { inherit haskellPackages nixpkgs; };

  # We pass a callPackage function to resolve any "extra" dependencies which
  # weren't given definitions by tinc (usually, those which aren't on Hackage)
  newPkgs = deps.packages { inherit (haskellPackages) callPackage; };

  # We extract the "extra" packages from the given haskellPackages, so they can
  # be included in our new overrides.
  extraPkgs = genAttrs extras (name: haskellPackages."${name}");
};
# Combine the given extras with those generated by tinc
haskellPackages.override { overrides = self: super: extraPkgs // newPkgs; }
